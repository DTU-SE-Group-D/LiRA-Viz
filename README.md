This repository contains the webapp of Group D's project for the 
Software Engineering 2 course (2023) of DTU.

You can find a running version of the application [here](http://se2-d.compute.dtu.dk:3000/).
You can also find the autogenerated documentation of the components of the application [here](https://dtu-se-group-d.github.io/LiRA-Viz/).

To develop the application, please follow the instructions bellow to install
the dependencies and then refer to the [wiki](https://github.com/DTU-SE-Group-D/LiRA-Viz/wiki)
to know how to start the development environment and read the development guidelines.

To deploy this application, please read the instructions bellow.

# Full deployment

The following sections describe how to deploy the software for the first time.

## Dependencies

The software relies on NodeJS, Postgres, Redis and Valhalla. The following sections describe how to install them, but 
if you already have them installed (locally or remotely), you can skip the section.

Redis and valhalla are installed using docker, so you need to install docker first. You can find the instructions [here](https://docs.docker.com/engine/install/).

### Node JS

Install Node JS at least version 18. You can use [Node Source](https://github.com/nodesource/distributions).

### Postgres

The software uses Postgres as database. You can create the database and user using the appropriate command.
Then you can run the following command to create the tables:

```sql
-- enable postgis
CREATE EXTENSION postgis;

-- create tables
create table survey
(
    id           uuid default uuid_generate_v4() not null
        constraint survey_pk
            primary key,
    section_geom geometry                        not null,
    timestamp    timestamp,
    data_source  varchar                         not null,
    survey_id    bigint
);

create table way
(
    id           uuid default uuid_generate_v4() not null
        primary key,
    way_name     text,
    osm_id       bigint                          not null
        unique,
    node_start   bigint                          not null,
    node_end     bigint                          not null,
    length       double precision                not null,
    section_geom geometry                        not null,
    isoneway     boolean                         not null
);

create table image
(
    id              uuid default uuid_generate_v4() not null
        primary key,
    image_path      text                            not null,
    type            text                            not null
        constraint check_image_type
            check (type = ANY
                   (ARRAY ['Image3D'::text, 'ImageInt'::text, 'ImageRng'::text, 'Overlay3D'::text, 'OverlayInt'::text, 'OverlayRng'::text, 'DashCamera'::text])),
    fk_survey_id    uuid
        constraint image_fk_survey
            references survey,
    distance_survey double precision,
    fk_way_id       uuid
        constraint image_fk_way
            references way,
    distance_way    double precision,
    timestamp       timestamp
);

create table measurement
(
    id              uuid default uuid_generate_v4() not null
        constraint measurement_pk
            primary key,
    type_index      integer                         not null,
    value           double precision                not null,
    timestamp       timestamp,
    fk_survey_id    uuid
        constraint measurement_fk
            references survey,
    distance_survey double precision,
    fk_way_id       uuid
        constraint measurement_fk_way
            references way,
    distance_way    double precision,
    
    latitude        double precision,
    longitude       double precision
);
```

_Don't forget to grant the permissions to the user you created and add the user and password to the `.env` file._

### Redis

Using docker, you can start Redis with the following command:

```shell
docker run -p 6379:6379 -d --name redis redis:alpine
```

### Valhalla

Regarding Valhalla, you can use the docker image provided by the [GIS-OPS](https://github.com/gis-ops/docker-valhalla). First download, the files
containing OSM data for the regions you want to use. You can find the list of available files [here](https://download.geofabrik.de/).
```shell
# download a file to custom_files and start valhalla
mkdir custom_files
cd custom_files
wget https://download.geofabrik.de/europe/denmark-latest.osm.pbf # Denmark
wget https://download.geofabrik.de/europe/italy-latest.osm.pbf # Italy
wget https://download.geofabrik.de/asia/gcc-states-latest.osm.pbf # Qatar
```

And then start the docker container:

```shell
docker run -dt --name valhalla_gis-ops -p 8002:8002 -v $PWD/custom_files:/custom_files -e server_threads=1 ghcr.io/gis-ops/docker-valhalla/valhalla:latest
```

_Note: the first time you run the container, it will take a while to start because Valhalla needs to preprocess the files._

## Backend

The backend is a NodeJS application that uses NestJS as web framework. It is located in the `backend` folder.

### Configuration

The backend uses environment variables to configure the application. You can find the list and explanation of the variables in the `.env.example` file.
You can copy the file and rename it to `.env` to use it.

### Installation, build

To install the backend, you need to install the dependencies first:

```shell
cd backend
npm install
npm run build
```

### Start

To keep the backend running after you close the terminal, we use `pm2`:

```shell
npm install -g pm2
```

And then start the backend with:

```shell
pm2 start dist/main.js 3002 -n backend
```

## Frontend

The frontend is a NodeJS application that uses ReactJS and is located in the `frontend` folder.

### Configuration

The frontend uses environment variables to configure the application. You can find the `.env` file in the `frontend` folder.
It is already configured to work with the DTU Compute server, but you can change it if you need.

### Installation, build

To install the frontend, you need to install the dependencies first:

```shell
cd frontend
npm install
npm run build
```

### Start

Similarly to the backend, we use `pm2` to keep the frontend running after you close the terminal:

```shell
pm2 serve build/ 3000 --spa -n frontend